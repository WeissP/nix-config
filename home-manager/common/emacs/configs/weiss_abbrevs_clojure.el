(with-eval-after-load 'clojure-mode
  (when (boundp 'clojure-mode-abbrev-table)
    (clear-abbrev-table clojure-mode-abbrev-table))

  (define-abbrev-table 'clojure-mode-abbrev-table
    '(
      ("pn" "println" weiss--ahf)
      ("prn" "(prn ▮)" weiss--ahf)
      ("def" "(def ▮)" weiss--ahf)
      ("key" "(key ▮)" weiss--ahf)
      ("fn" "(fn [▮])" weiss--ahf)
      ("for" "(for [▮])" weiss--ahf)
      ("update" "(update ▮)" weiss--ahf)
      ("defn" "(defn ▮ \n[]\n\n)" weiss--ahf)
      ("l" "let" weiss--ahf)
      ("let" "(let [▮]\n)" weiss--ahf)
      ("loop" "(loop [▮\n]\n(if \n(recur )))" weiss--ahf)
      ("case" "(case ▮\n\n)" weiss--ahf)
      ("println" "(println ▮)" weiss--ahf)
      ("print" "(print ▮)" weiss--ahf)
      ("into" "(into ▮)" weiss--ahf)
      ("red" "(reduce ▮)" weiss--ahf)
      ("set" "(set ▮)" weiss--ahf)
      ("when" "(when ▮)" weiss--ahf)
      ("if" "(if ▮)" weiss--ahf)
      ("not" "(not ▮)" weiss--ahf)
      ("eq" "(= ▮)" weiss--ahf)
      ("conj" "(conj ▮)" weiss--ahf)
      ("map" "(map ▮)" weiss--ahf)
      ("css" "(clojure.string/split ▮ #\"\")" weiss--ahf)
      ("sl" "slurp"  weiss--ahf)
      ("slurp" "(slurp ▮)" weiss--ahf)
      ("fst" "first" weiss--ahf)
      ("first" "(first ▮)" weiss--ahf)
      ("snd" "second" weiss--ahf)
      ("second" "(second ▮)" weiss--ahf)
      ("wt" "(defn weiss-test\n[▮]\n\n)" weiss--ahf)
      ("cons" "(cons ▮)" weiss--ahf)
      ("ar" "(-> ▮)" weiss--ahf)
      ("arr" "(->> ▮)" weiss--ahf)
      ("and" "(and ▮)" weiss--ahf)
      ("ct" "count" weiss--ahf)
      ("apply" "(apply ▮)" weiss--ahf)
      ("concat" "(concat ▮)" weiss--ahf)
      ("rest" "(rest ▮)" weiss--ahf)
      ("count" "(count ▮)" weiss--ahf)
      ("nth" "(nth ▮)" weiss--ahf)
      ("reduce" "(reduce ▮)" weiss--ahf)
      ("do" "(do \n▮\n)" weiss--ahf)
      ("str" "(str ▮)"  weiss--ahf)
      ("cs" "clojure.string"  weiss--ahf)
      ("clojure.string" "(clojure.string/▮)"  weiss--ahf)
      ("pop" "(pop ▮)"  weiss--ahf)
      ("drop" "(drop 1 ▮)"  weiss--ahf)
      ("or" "(or ▮)"  weiss--ahf)
      ("f" "format"  weiss--ahf)
      ("format" "(format \"%s\" ▮)"  weiss--ahf)
      ("take" "(take ▮)"  weiss--ahf)
      ("cond" "(cond\n ▮\n:else\n)"  weiss--ahf)
      ("last" "(last ▮)"  weiss--ahf)
      
      ("hfm" "(sql/format)")
      ("hfmp" "(sql/format {:pretty true})")
      ("hct" ":%count.*" weiss--ahf)
      ("hdi" "(h/select-distinct :▮) " weiss--ahf)
      ("hgb" "(h/group-by :▮)" weiss--ahf)
      ("hii" "(h/insert-into :▮)\n(h/values [{:}])" weiss--ahf)
      ("hli" "(h/limit ▮)" weiss--ahf)
      ("hob" "(h/order-by :▮)" weiss--ahf)
      ("hsf" "(h/select :▮)\n(h/from :)" weiss--ahf)
      ("hsfw" "(h/select :▮)\n(h/from :)\n(h/where [:= :])" weiss--ahf)
      ("sl" "(h/select :▮)" weiss--ahf)
      ("hwh" "(h/where [:= :▮])" weiss--ahf)
      ("heq" "[:= :▮]" weiss--ahf)
      ("hlj" "(h/join :▮ [:= : :])" weiss--ahf)
      ("hljo" "(h/left-join [:▮] [:= : :])" weiss--ahf)
      ("not" ":not▮" weiss--ahf)
      ("hin" "[:in : []]" weiss--ahf)    
      ("hor" "[:or\n]" weiss--ahf)
      ("thex" "(throw (Exception. (str ▮)))" weiss--ahf)
      ("reduce" "(reduce (fn [res elem] ▮) l)" weiss--ahf)
      ("doseq" "(doseq [▮\n]\n)" weiss--ahf)
      ("some" "(some ▮)" weiss--ahf)
      ("try" "(try (▮ (throw (ex-info \"exception\" {})))\n(catch clojure.lang.ExceptionInfo e (prn \"caught\" e)))" weiss--ahf)    

      ))
  )




;; parent: 
(provide 'weiss_abbrevs_clojure)
